/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Semux API
 * Semux is an experimental high-performance blockchain platform that powers decentralized application.
 *
 * OpenAPI spec version: 2.5.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import fetch from "unfetch";
const portableFetch = fetch;
import { Configuration } from "./configuration";

const BASE_PATH = "/v2.5.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountType
 */
export interface AccountType {
    /**
     * The address of this account
     * @type {string}
     * @memberof AccountType
     */
    address?: string;
    /**
     * The available balance of this account
     * @type {string}
     * @memberof AccountType
     */
    available?: string;
    /**
     * The locked balance of this account
     * @type {string}
     * @memberof AccountType
     */
    locked?: string;
    /**
     * The nonce of this account
     * @type {string}
     * @memberof AccountType
     */
    nonce?: string;
    /**
     * The number of transactions received/sent
     * @type {number}
     * @memberof AccountType
     */
    transactionCount?: number;
    /**
     * The number of internal transactions received/sent
     * @type {number}
     * @memberof AccountType
     */
    internalTransactionCount?: number;
    /**
     * The number of pending transaction from/to this account
     * @type {number}
     * @memberof AccountType
     */
    pendingTransactionCount?: number;
}
/**
 * 
 * @export
 * @interface AccountVoteType
 */
export interface AccountVoteType {
    /**
     * 
     * @type {DelegateType}
     * @memberof AccountVoteType
     */
    delegate?: DelegateType;
    /**
     * Total votes from this account to the delegate
     * @type {string}
     * @memberof AccountVoteType
     */
    votes?: string;
}
/**
 * 
 * @export
 * @interface AddNodeResponse
 */
export interface AddNodeResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof AddNodeResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof AddNodeResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface AddToBlacklistResponse
 */
export interface AddToBlacklistResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof AddToBlacklistResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof AddToBlacklistResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface AddToWhitelistResponse
 */
export interface AddToWhitelistResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof AddToWhitelistResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof AddToWhitelistResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface BlockType
 */
export interface BlockType {
    /**
     * The block hash
     * @type {string}
     * @memberof BlockType
     */
    hash?: string;
    /**
     * The block number
     * @type {string}
     * @memberof BlockType
     */
    number?: string;
    /**
     * The view number. # of additional BFT rounds to generated this block
     * @type {number}
     * @memberof BlockType
     */
    view?: number;
    /**
     * The block producer's address
     * @type {string}
     * @memberof BlockType
     */
    coinbase?: string;
    /**
     * The hash of the parent block
     * @type {string}
     * @memberof BlockType
     */
    parentHash?: string;
    /**
     * Block timestamp in milliseconds specified by the block producer.
     * @type {string}
     * @memberof BlockType
     */
    timestamp?: string;
    /**
     * The Merkle root hash of the transactions
     * @type {string}
     * @memberof BlockType
     */
    transactionsRoot?: string;
    /**
     * The Merkle root hash of the results
     * @type {string}
     * @memberof BlockType
     */
    resultsRoot?: string;
    /**
     * The state root hash. Not enabled yet!
     * @type {string}
     * @memberof BlockType
     */
    stateRoot?: string;
    /**
     * The extra data of this block
     * @type {string}
     * @memberof BlockType
     */
    data?: string;
    /**
     * A list of transaction in the block
     * @type {Array<TransactionType>}
     * @memberof BlockType
     */
    transactions?: Array<TransactionType>;
}
/**
 * 
 * @export
 * @interface ComposeRawTransactionResponse
 */
export interface ComposeRawTransactionResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof ComposeRawTransactionResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof ComposeRawTransactionResponse
     */
    message?: string;
    /**
     * The composed raw transaction encoded in hexadecimal string
     * @type {string}
     * @memberof ComposeRawTransactionResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface CreateAccountResponse
 */
export interface CreateAccountResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof CreateAccountResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof CreateAccountResponse
     */
    message?: string;
    /**
     * The address of the newly created account
     * @type {string}
     * @memberof CreateAccountResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface DelegateType
 */
export interface DelegateType {
    /**
     * Delegate address
     * @type {string}
     * @memberof DelegateType
     */
    address?: string;
    /**
     * Delegate name
     * @type {string}
     * @memberof DelegateType
     */
    name?: string;
    /**
     * Delegate registration block number
     * @type {string}
     * @memberof DelegateType
     */
    registeredAt?: string;
    /**
     * Total votes of the delegate
     * @type {string}
     * @memberof DelegateType
     */
    votes?: string;
    /**
     * The number of blocks produced by this delegate
     * @type {string}
     * @memberof DelegateType
     */
    blocksForged?: string;
    /**
     * Forged blocks when the delegate is a primary validator
     * @type {string}
     * @memberof DelegateType
     */
    turnsHit?: string;
    /**
     * Missed blocks when the delegate is a primary validator
     * @type {string}
     * @memberof DelegateType
     */
    turnsMissed?: string;
    /**
     * Whether the delegate is currently a validator
     * @type {boolean}
     * @memberof DelegateType
     */
    validator?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteAccountResponse
 */
export interface DeleteAccountResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof DeleteAccountResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof DeleteAccountResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface DoTransactionResponse
 */
export interface DoTransactionResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof DoTransactionResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof DoTransactionResponse
     */
    message?: string;
    /**
     * The transaction hash
     * @type {string}
     * @memberof DoTransactionResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface EstimateGasResponse
 */
export interface EstimateGasResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof EstimateGasResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof EstimateGasResponse
     */
    message?: string;
    /**
     * The estimated gas usage
     * @type {string}
     * @memberof EstimateGasResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface FailureResponse
 */
export interface FailureResponse {
    /**
     * This property is deprecated, always false
     * @type {boolean}
     * @memberof FailureResponse
     */
    success?: boolean;
    /**
     * The exact failing cause
     * @type {string}
     * @memberof FailureResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GetAccountCodeResponse
 */
export interface GetAccountCodeResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountCodeResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountCodeResponse
     */
    message?: string;
    /**
     * Account code encoded in hexadecimal string
     * @type {string}
     * @memberof GetAccountCodeResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface GetAccountInternalTransactionsResponse
 */
export interface GetAccountInternalTransactionsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountInternalTransactionsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountInternalTransactionsResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<InternalTransactionType>}
     * @memberof GetAccountInternalTransactionsResponse
     */
    result?: Array<InternalTransactionType>;
}
/**
 * 
 * @export
 * @interface GetAccountPendingTransactionsResponse
 */
export interface GetAccountPendingTransactionsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountPendingTransactionsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountPendingTransactionsResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<TransactionType>}
     * @memberof GetAccountPendingTransactionsResponse
     */
    result?: Array<TransactionType>;
}
/**
 * 
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountResponse
     */
    message?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof GetAccountResponse
     */
    result?: AccountType;
}
/**
 * 
 * @export
 * @interface GetAccountStorageResponse
 */
export interface GetAccountStorageResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountStorageResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountStorageResponse
     */
    message?: string;
    /**
     * Account storage encoded in hexadecimal string
     * @type {string}
     * @memberof GetAccountStorageResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface GetAccountTransactionsResponse
 */
export interface GetAccountTransactionsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountTransactionsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountTransactionsResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<TransactionType>}
     * @memberof GetAccountTransactionsResponse
     */
    result?: Array<TransactionType>;
}
/**
 * 
 * @export
 * @interface GetAccountVotesResponse
 */
export interface GetAccountVotesResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountVotesResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountVotesResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<AccountVoteType>}
     * @memberof GetAccountVotesResponse
     */
    result?: Array<AccountVoteType>;
}
/**
 * 
 * @export
 * @interface GetAccountsResponse
 */
export interface GetAccountsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetAccountsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetAccountsResponse
     */
    message?: string;
    /**
     * A list of account addresses
     * @type {Array<string>}
     * @memberof GetAccountsResponse
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetBlockResponse
 */
export interface GetBlockResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetBlockResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetBlockResponse
     */
    message?: string;
    /**
     * 
     * @type {BlockType}
     * @memberof GetBlockResponse
     */
    result?: BlockType;
}
/**
 * 
 * @export
 * @interface GetDelegateResponse
 */
export interface GetDelegateResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetDelegateResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetDelegateResponse
     */
    message?: string;
    /**
     * 
     * @type {DelegateType}
     * @memberof GetDelegateResponse
     */
    result?: DelegateType;
}
/**
 * 
 * @export
 * @interface GetDelegatesResponse
 */
export interface GetDelegatesResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetDelegatesResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetDelegatesResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<DelegateType>}
     * @memberof GetDelegatesResponse
     */
    result?: Array<DelegateType>;
}
/**
 * 
 * @export
 * @interface GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetInfoResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetInfoResponse
     */
    message?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof GetInfoResponse
     */
    result?: InfoType;
}
/**
 * 
 * @export
 * @interface GetLatestBlockNumberResponse
 */
export interface GetLatestBlockNumberResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetLatestBlockNumberResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetLatestBlockNumberResponse
     */
    message?: string;
    /**
     * The number of the latest block
     * @type {string}
     * @memberof GetLatestBlockNumberResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface GetLatestBlockResponse
 */
export interface GetLatestBlockResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetLatestBlockResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetLatestBlockResponse
     */
    message?: string;
    /**
     * 
     * @type {BlockType}
     * @memberof GetLatestBlockResponse
     */
    result?: BlockType;
}
/**
 * 
 * @export
 * @interface GetPeersResponse
 */
export interface GetPeersResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetPeersResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetPeersResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<PeerType>}
     * @memberof GetPeersResponse
     */
    result?: Array<PeerType>;
}
/**
 * 
 * @export
 * @interface GetPendingTransactionsResponse
 */
export interface GetPendingTransactionsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetPendingTransactionsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetPendingTransactionsResponse
     */
    message?: string;
    /**
     * 
     * @type {Array<TransactionType>}
     * @memberof GetPendingTransactionsResponse
     */
    result?: Array<TransactionType>;
}
/**
 * 
 * @export
 * @interface GetSyncingStatusResponse
 */
export interface GetSyncingStatusResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetSyncingStatusResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetSyncingStatusResponse
     */
    message?: string;
    /**
     * 
     * @type {SyncingStatusType}
     * @memberof GetSyncingStatusResponse
     */
    result?: SyncingStatusType;
}
/**
 * 
 * @export
 * @interface GetTransactionLimitsResponse
 */
export interface GetTransactionLimitsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetTransactionLimitsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetTransactionLimitsResponse
     */
    message?: string;
    /**
     * 
     * @type {TransactionLimitsType}
     * @memberof GetTransactionLimitsResponse
     */
    result?: TransactionLimitsType;
}
/**
 * 
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetTransactionResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetTransactionResponse
     */
    message?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof GetTransactionResponse
     */
    result?: TransactionType;
}
/**
 * 
 * @export
 * @interface GetTransactionResultResponse
 */
export interface GetTransactionResultResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetTransactionResultResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetTransactionResultResponse
     */
    message?: string;
    /**
     * 
     * @type {TransactionResultType}
     * @memberof GetTransactionResultResponse
     */
    result?: TransactionResultType;
}
/**
 * 
 * @export
 * @interface GetValidatorsResponse
 */
export interface GetValidatorsResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetValidatorsResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetValidatorsResponse
     */
    message?: string;
    /**
     * A list of validator addresses
     * @type {Array<string>}
     * @memberof GetValidatorsResponse
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetVoteResponse
 */
export interface GetVoteResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetVoteResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetVoteResponse
     */
    message?: string;
    /**
     * Total votes in nanoSEM
     * @type {string}
     * @memberof GetVoteResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface GetVotesResponse
 */
export interface GetVotesResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof GetVotesResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof GetVotesResponse
     */
    message?: string;
    /**
     * A map of [voter address] => [votes]
     * @type {{ [key: string]: string; }}
     * @memberof GetVotesResponse
     */
    result?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InfoType
 */
export interface InfoType {
    /**
     * The connected network
     * @type {string}
     * @memberof InfoType
     */
    network?: InfoType.NetworkEnum;
    /**
     * The features supported
     * @type {Array<string>}
     * @memberof InfoType
     */
    capabilities?: Array<string>;
    /**
     * The client identifier string
     * @type {string}
     * @memberof InfoType
     */
    clientId?: string;
    /**
     * The address used for establishing connections to the network
     * @type {string}
     * @memberof InfoType
     */
    coinbase?: string;
    /**
     * The number of the last block
     * @type {string}
     * @memberof InfoType
     */
    latestBlockNumber?: string;
    /**
     * The hash of the last block
     * @type {string}
     * @memberof InfoType
     */
    latestBlockHash?: string;
    /**
     * The number of actively connected peers
     * @type {number}
     * @memberof InfoType
     */
    activePeers?: number;
    /**
     * The number of transactions in pending pool
     * @type {number}
     * @memberof InfoType
     */
    pendingTransactions?: number;
}

/**
 * @export
 * @namespace InfoType
 */
export namespace InfoType {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MAINNET = <any> 'MAINNET',
        TESTNET = <any> 'TESTNET',
        DEVNET = <any> 'DEVNET'
    }
}
/**
 * 
 * @export
 * @interface InternalTransactionType
 */
export interface InternalTransactionType {
    /**
     * The root transaction hash
     * @type {string}
     * @memberof InternalTransactionType
     */
    rootTransactionHash?: string;
    /**
     * Whether this transaction is rejected
     * @type {boolean}
     * @memberof InternalTransactionType
     */
    rejected?: boolean;
    /**
     * Call depth
     * @type {string}
     * @memberof InternalTransactionType
     */
    depth?: string;
    /**
     * Call index
     * @type {string}
     * @memberof InternalTransactionType
     */
    index?: string;
    /**
     * Call type, possibly CALL, DELEGATECALL, CALLCODE, CREATE, CREATE2
     * @type {string}
     * @memberof InternalTransactionType
     */
    type?: string;
    /**
     * Sender address
     * @type {string}
     * @memberof InternalTransactionType
     */
    from?: string;
    /**
     * Receiver address
     * @type {string}
     * @memberof InternalTransactionType
     */
    to?: string;
    /**
     * The sender's nonce
     * @type {string}
     * @memberof InternalTransactionType
     */
    nonce?: string;
    /**
     * The gas limit
     * @type {string}
     * @memberof InternalTransactionType
     */
    gas?: string;
    /**
     * The gas Price
     * @type {string}
     * @memberof InternalTransactionType
     */
    gasPrice?: string;
    /**
     * The value being passed, in nano SEM
     * @type {string}
     * @memberof InternalTransactionType
     */
    value?: string;
    /**
     * The data being passed, in hexadecimal string
     * @type {string}
     * @memberof InternalTransactionType
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface LocalCallResponse
 */
export interface LocalCallResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof LocalCallResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof LocalCallResponse
     */
    message?: string;
    /**
     * 
     * @type {TransactionResultType}
     * @memberof LocalCallResponse
     */
    result?: TransactionResultType;
}
/**
 * 
 * @export
 * @interface LocalCreateResponse
 */
export interface LocalCreateResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof LocalCreateResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof LocalCreateResponse
     */
    message?: string;
    /**
     * 
     * @type {TransactionResultType}
     * @memberof LocalCreateResponse
     */
    result?: TransactionResultType;
}
/**
 * 
 * @export
 * @interface LogInfoType
 */
export interface LogInfoType {
    /**
     * Contract address
     * @type {string}
     * @memberof LogInfoType
     */
    address?: string;
    /**
     * Log data encoded in hexadecimal string
     * @type {string}
     * @memberof LogInfoType
     */
    data?: string;
    /**
     * Log topics encoded in hexadecimal string
     * @type {Array<string>}
     * @memberof LogInfoType
     */
    topics?: Array<string>;
}
/**
 * 
 * @export
 * @interface PeerType
 */
export interface PeerType {
    /**
     * The IP address
     * @type {string}
     * @memberof PeerType
     */
    ip?: string;
    /**
     * The port number
     * @type {number}
     * @memberof PeerType
     */
    port?: number;
    /**
     * The network version
     * @type {number}
     * @memberof PeerType
     */
    networkVersion?: number;
    /**
     * The client the peer is using
     * @type {string}
     * @memberof PeerType
     */
    clientId?: string;
    /**
     * The id of the peer
     * @type {string}
     * @memberof PeerType
     */
    peerId?: string;
    /**
     * The latest block number of the peer
     * @type {string}
     * @memberof PeerType
     */
    latestBlockNumber?: string;
    /**
     * Latency between this node and the peer
     * @type {string}
     * @memberof PeerType
     */
    latency?: string;
    /**
     * The features supported by the peer
     * @type {Array<string>}
     * @memberof PeerType
     */
    capabilities?: Array<string>;
}
/**
 * 
 * @export
 * @interface SignMessageResponse
 */
export interface SignMessageResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof SignMessageResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof SignMessageResponse
     */
    message?: string;
    /**
     * The message signature encoded in hexadecimal string
     * @type {string}
     * @memberof SignMessageResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface SignRawTransactionResponse
 */
export interface SignRawTransactionResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof SignRawTransactionResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof SignRawTransactionResponse
     */
    message?: string;
    /**
     * The signed raw transaction encoded in hexadecimal string
     * @type {string}
     * @memberof SignRawTransactionResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface SyncingStatusType
 */
export interface SyncingStatusType {
    /**
     * Whether the node is syncing
     * @type {boolean}
     * @memberof SyncingStatusType
     */
    syncing: boolean;
    /**
     * The block height at which the sync started
     * @type {string}
     * @memberof SyncingStatusType
     */
    startingHeight?: string;
    /**
     * The current block height
     * @type {string}
     * @memberof SyncingStatusType
     */
    currentHeight?: string;
    /**
     * The target block height
     * @type {string}
     * @memberof SyncingStatusType
     */
    targetHeight?: string;
}
/**
 * 
 * @export
 * @interface TransactionLimitsType
 */
export interface TransactionLimitsType {
    /**
     * The maximum transaction size in bytes
     * @type {number}
     * @memberof TransactionLimitsType
     */
    maxTransactionDataSize?: number;
    /**
     * The minimum transaction fee in nano SEM
     * @type {string}
     * @memberof TransactionLimitsType
     */
    minTransactionFee?: string;
    /**
     * The amount of nano SEM required to burn for delegate registration
     * @type {string}
     * @memberof TransactionLimitsType
     */
    minDelegateBurnAmount?: string;
}
/**
 * 
 * @export
 * @interface TransactionResultType
 */
export interface TransactionResultType {
    /**
     * The number of block that included the transaction
     * @type {string}
     * @memberof TransactionResultType
     */
    blockNumber?: string;
    /**
     * The status of the transaction
     * @type {string}
     * @memberof TransactionResultType
     */
    code?: string;
    /**
     * Logs produced when executing this transaction
     * @type {Array<LogInfoType>}
     * @memberof TransactionResultType
     */
    logs?: Array<LogInfoType>;
    /**
     * Return data encoded in hexadecimal string
     * @type {string}
     * @memberof TransactionResultType
     */
    returnData?: string;
    /**
     * Contract address if this is a CREATE transaction, or NULL
     * @type {string}
     * @memberof TransactionResultType
     */
    contractAddress?: string;
    /**
     * The gas limit set by the sender
     * @type {string}
     * @memberof TransactionResultType
     */
    gas?: string;
    /**
     * The gas Price set by the sender
     * @type {string}
     * @memberof TransactionResultType
     */
    gasPrice?: string;
    /**
     * The gas consumed. For non-VM transactions, this field is zero
     * @type {string}
     * @memberof TransactionResultType
     */
    gasUsed?: string;
    /**
     * The transaction fee in nano SEM. For VM transactions, this field is zero
     * @type {string}
     * @memberof TransactionResultType
     */
    fee?: string;
    /**
     * Internal transactions generated when executing this transaction
     * @type {Array<InternalTransactionType>}
     * @memberof TransactionResultType
     */
    internalTransactions?: Array<InternalTransactionType>;
}
/**
 * 
 * @export
 * @interface TransactionType
 */
export interface TransactionType {
    /**
     * The transaction hash
     * @type {string}
     * @memberof TransactionType
     */
    hash?: string;
    /**
     * The transaction type
     * @type {string}
     * @memberof TransactionType
     */
    type?: TransactionType.TypeEnum;
    /**
     * Sender's address
     * @type {string}
     * @memberof TransactionType
     */
    from?: string;
    /**
     * Recipient's address
     * @type {string}
     * @memberof TransactionType
     */
    to?: string;
    /**
     * Transaction value in nano SEM
     * @type {string}
     * @memberof TransactionType
     */
    value?: string;
    /**
     * Transaction fee in nano SEM. For CREATE/CALL, this field is zero; use gas instead
     * @type {string}
     * @memberof TransactionType
     */
    fee?: string;
    /**
     * The nonce of the sender
     * @type {string}
     * @memberof TransactionType
     */
    nonce?: string;
    /**
     * Transaction timestamp in milliseconds specified by the sender. There can be a time drift up to 2 hours.
     * @type {string}
     * @memberof TransactionType
     */
    timestamp?: string;
    /**
     * Transaction data encoded in hexadecimal string
     * @type {string}
     * @memberof TransactionType
     */
    data?: string;
    /**
     * The gas limit set by the sender
     * @type {string}
     * @memberof TransactionType
     */
    gas?: string;
    /**
     * The gas Price set by the sender
     * @type {string}
     * @memberof TransactionType
     */
    gasPrice?: string;
}

/**
 * @export
 * @namespace TransactionType
 */
export namespace TransactionType {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        COINBASE = <any> 'COINBASE',
        TRANSFER = <any> 'TRANSFER',
        DELEGATE = <any> 'DELEGATE',
        VOTE = <any> 'VOTE',
        UNVOTE = <any> 'UNVOTE',
        CREATE = <any> 'CREATE',
        CALL = <any> 'CALL'
    }
}
/**
 * 
 * @export
 * @interface VerifyMessageResponse
 */
export interface VerifyMessageResponse {
    /**
     * This property is deprecated, always true
     * @type {boolean}
     * @memberof VerifyMessageResponse
     */
    success?: boolean;
    /**
     * Success/error message
     * @type {string}
     * @memberof VerifyMessageResponse
     */
    message?: string;
    /**
     * Whether the signature is valid
     * @type {boolean}
     * @memberof VerifyMessageResponse
     */
    valid?: boolean;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the basic information about an account.
         * @summary Get account info
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccount.');
            }
            const localVarPath = `/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the code of an account.
         * @summary Get account code
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCode(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountCode.');
            }
            const localVarPath = `/account/code`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns internal transactions from/to an account.
         * @summary Get account internal transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInternalTransactions(address: string, from: string, to: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountInternalTransactions.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getAccountInternalTransactions.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getAccountInternalTransactions.');
            }
            const localVarPath = `/account/internal-transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pending transactions from/to an account.
         * @summary Get pending transactions of the account
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPendingTransactions(address: string, from: string, to: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountPendingTransactions.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getAccountPendingTransactions.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getAccountPendingTransactions.');
            }
            const localVarPath = `/account/pending-transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the storage value mapped to the given key of an account.
         * @summary Get account storage
         * @param {string} address Address of account
         * @param {string} key The storage key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStorage(address: string, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountStorage.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getAccountStorage.');
            }
            const localVarPath = `/account/storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns transactions from/to an account.
         * @summary Get account transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(address: string, from: string, to: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountTransactions.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getAccountTransactions.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getAccountTransactions.');
            }
            const localVarPath = `/account/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns votes from the account.
         * @summary Get account votes
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountVotes(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getAccountVotes.');
            }
            const localVarPath = `/account/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the basic information about an account.
         * @summary Get account info
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccount(address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the code of an account.
         * @summary Get account code
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCode(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountCodeResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountCode(address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns internal transactions from/to an account.
         * @summary Get account internal transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInternalTransactions(address: string, from: string, to: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountInternalTransactionsResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountInternalTransactions(address, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns pending transactions from/to an account.
         * @summary Get pending transactions of the account
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPendingTransactions(address: string, from: string, to: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountPendingTransactionsResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountPendingTransactions(address, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the storage value mapped to the given key of an account.
         * @summary Get account storage
         * @param {string} address Address of account
         * @param {string} key The storage key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStorage(address: string, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountStorageResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountStorage(address, key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns transactions from/to an account.
         * @summary Get account transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(address: string, from: string, to: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountTransactionsResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountTransactions(address, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns votes from the account.
         * @summary Get account votes
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountVotes(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountVotesResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountVotes(address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the basic information about an account.
         * @summary Get account info
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(address: string, options?: any) {
            return AccountApiFp(configuration).getAccount(address, options)(fetch, basePath);
        },
        /**
         * Returns the code of an account.
         * @summary Get account code
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCode(address: string, options?: any) {
            return AccountApiFp(configuration).getAccountCode(address, options)(fetch, basePath);
        },
        /**
         * Returns internal transactions from/to an account.
         * @summary Get account internal transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInternalTransactions(address: string, from: string, to: string, options?: any) {
            return AccountApiFp(configuration).getAccountInternalTransactions(address, from, to, options)(fetch, basePath);
        },
        /**
         * Returns pending transactions from/to an account.
         * @summary Get pending transactions of the account
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPendingTransactions(address: string, from: string, to: string, options?: any) {
            return AccountApiFp(configuration).getAccountPendingTransactions(address, from, to, options)(fetch, basePath);
        },
        /**
         * Returns the storage value mapped to the given key of an account.
         * @summary Get account storage
         * @param {string} address Address of account
         * @param {string} key The storage key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStorage(address: string, key: string, options?: any) {
            return AccountApiFp(configuration).getAccountStorage(address, key, options)(fetch, basePath);
        },
        /**
         * Returns transactions from/to an account.
         * @summary Get account transactions
         * @param {string} address Address of account
         * @param {string} from Starting range of transactions
         * @param {string} to Ending range of transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(address: string, from: string, to: string, options?: any) {
            return AccountApiFp(configuration).getAccountTransactions(address, from, to, options)(fetch, basePath);
        },
        /**
         * Returns votes from the account.
         * @summary Get account votes
         * @param {string} address Address of account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountVotes(address: string, options?: any) {
            return AccountApiFp(configuration).getAccountVotes(address, options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Returns the basic information about an account.
     * @summary Get account info
     * @param {string} address Address of account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(address: string, options?: any) {
        return AccountApiFp(this.configuration).getAccount(address, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the code of an account.
     * @summary Get account code
     * @param {string} address Address of account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountCode(address: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountCode(address, options)(this.fetch, this.basePath);
    }

    /**
     * Returns internal transactions from/to an account.
     * @summary Get account internal transactions
     * @param {string} address Address of account
     * @param {string} from Starting range of transactions
     * @param {string} to Ending range of transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountInternalTransactions(address: string, from: string, to: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountInternalTransactions(address, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Returns pending transactions from/to an account.
     * @summary Get pending transactions of the account
     * @param {string} address Address of account
     * @param {string} from Starting range of transactions
     * @param {string} to Ending range of transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountPendingTransactions(address: string, from: string, to: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountPendingTransactions(address, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the storage value mapped to the given key of an account.
     * @summary Get account storage
     * @param {string} address Address of account
     * @param {string} key The storage key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountStorage(address: string, key: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountStorage(address, key, options)(this.fetch, this.basePath);
    }

    /**
     * Returns transactions from/to an account.
     * @summary Get account transactions
     * @param {string} address Address of account
     * @param {string} from Starting range of transactions
     * @param {string} to Ending range of transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountTransactions(address: string, from: string, to: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountTransactions(address, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Returns votes from the account.
     * @summary Get account votes
     * @param {string} address Address of account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountVotes(address: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountVotes(address, options)(this.fetch, this.basePath);
    }

}
/**
 * BlockchainApi - fetch parameter creator
 * @export
 */
export const BlockchainApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a block by block hash.
         * @summary Get block by hash
         * @param {string} hash Hash of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHash(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getBlockByHash.');
            }
            const localVarPath = `/block-by-hash`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a block by block number.
         * @summary Get block by number
         * @param {string} number Number of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByNumber(number: string, options: any = {}): FetchArgs {
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling getBlockByNumber.');
            }
            const localVarPath = `/block-by-number`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest block.
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options: any = {}): FetchArgs {
            const localVarPath = `/latest-block`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the number of the latest block.
         * @summary Get the number of the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlockNumber(options: any = {}): FetchArgs {
            const localVarPath = `/latest-block-number`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a transactions if exists.
         * @summary Get transaction
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getTransaction.');
            }
            const localVarPath = `/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns transaction limitations including minimum transaction fee and maximum transaction size.
         * @summary Get transaction limits
         * @param {string} type Type of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLimits(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getTransactionLimits.');
            }
            const localVarPath = `/transaction-limits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the result of the requested transaction.
         * @summary Get transaction result
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionResult(hash: string, options: any = {}): FetchArgs {
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling getTransactionResult.');
            }
            const localVarPath = `/transaction-result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockchainApi - functional programming interface
 * @export
 */
export const BlockchainApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a block by block hash.
         * @summary Get block by hash
         * @param {string} hash Hash of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHash(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetBlockResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getBlockByHash(hash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a block by block number.
         * @summary Get block by number
         * @param {string} number Number of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByNumber(number: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetBlockResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getBlockByNumber(number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the latest block.
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetLatestBlockResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getLatestBlock(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the number of the latest block.
         * @summary Get the number of the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlockNumber(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetLatestBlockNumberResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getLatestBlockNumber(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a transactions if exists.
         * @summary Get transaction
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetTransactionResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getTransaction(hash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns transaction limitations including minimum transaction fee and maximum transaction size.
         * @summary Get transaction limits
         * @param {string} type Type of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLimits(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetTransactionLimitsResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getTransactionLimits(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the result of the requested transaction.
         * @summary Get transaction result
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionResult(hash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetTransactionResultResponse> {
            const localVarFetchArgs = BlockchainApiFetchParamCreator(configuration).getTransactionResult(hash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlockchainApi - factory interface
 * @export
 */
export const BlockchainApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a block by block hash.
         * @summary Get block by hash
         * @param {string} hash Hash of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHash(hash: string, options?: any) {
            return BlockchainApiFp(configuration).getBlockByHash(hash, options)(fetch, basePath);
        },
        /**
         * Returns a block by block number.
         * @summary Get block by number
         * @param {string} number Number of block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByNumber(number: string, options?: any) {
            return BlockchainApiFp(configuration).getBlockByNumber(number, options)(fetch, basePath);
        },
        /**
         * Returns the latest block.
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options?: any) {
            return BlockchainApiFp(configuration).getLatestBlock(options)(fetch, basePath);
        },
        /**
         * Returns the number of the latest block.
         * @summary Get the number of the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlockNumber(options?: any) {
            return BlockchainApiFp(configuration).getLatestBlockNumber(options)(fetch, basePath);
        },
        /**
         * Returns a transactions if exists.
         * @summary Get transaction
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(hash: string, options?: any) {
            return BlockchainApiFp(configuration).getTransaction(hash, options)(fetch, basePath);
        },
        /**
         * Returns transaction limitations including minimum transaction fee and maximum transaction size.
         * @summary Get transaction limits
         * @param {string} type Type of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLimits(type: string, options?: any) {
            return BlockchainApiFp(configuration).getTransactionLimits(type, options)(fetch, basePath);
        },
        /**
         * Returns the result of the requested transaction.
         * @summary Get transaction result
         * @param {string} hash Transaction hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionResult(hash: string, options?: any) {
            return BlockchainApiFp(configuration).getTransactionResult(hash, options)(fetch, basePath);
        },
    };
};

/**
 * BlockchainApi - object-oriented interface
 * @export
 * @class BlockchainApi
 * @extends {BaseAPI}
 */
export class BlockchainApi extends BaseAPI {
    /**
     * Returns a block by block hash.
     * @summary Get block by hash
     * @param {string} hash Hash of block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getBlockByHash(hash: string, options?: any) {
        return BlockchainApiFp(this.configuration).getBlockByHash(hash, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a block by block number.
     * @summary Get block by number
     * @param {string} number Number of block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getBlockByNumber(number: string, options?: any) {
        return BlockchainApiFp(this.configuration).getBlockByNumber(number, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the latest block.
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getLatestBlock(options?: any) {
        return BlockchainApiFp(this.configuration).getLatestBlock(options)(this.fetch, this.basePath);
    }

    /**
     * Returns the number of the latest block.
     * @summary Get the number of the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getLatestBlockNumber(options?: any) {
        return BlockchainApiFp(this.configuration).getLatestBlockNumber(options)(this.fetch, this.basePath);
    }

    /**
     * Returns a transactions if exists.
     * @summary Get transaction
     * @param {string} hash Transaction hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getTransaction(hash: string, options?: any) {
        return BlockchainApiFp(this.configuration).getTransaction(hash, options)(this.fetch, this.basePath);
    }

    /**
     * Returns transaction limitations including minimum transaction fee and maximum transaction size.
     * @summary Get transaction limits
     * @param {string} type Type of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getTransactionLimits(type: string, options?: any) {
        return BlockchainApiFp(this.configuration).getTransactionLimits(type, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the result of the requested transaction.
     * @summary Get transaction result
     * @param {string} hash Transaction hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public getTransactionResult(hash: string, options?: any) {
        return BlockchainApiFp(this.configuration).getTransactionResult(hash, options)(this.fetch, this.basePath);
    }

}
/**
 * DelegateApi - fetch parameter creator
 * @export
 */
export const DelegateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the information about delegate.
         * @summary Get delegate info
         * @param {string} address Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegate(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getDelegate.');
            }
            const localVarPath = `/delegate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of delegates.
         * @summary Get all delegates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegates(options: any = {}): FetchArgs {
            const localVarPath = `/delegates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of validators in Semux addresses.
         * @summary Get all validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options: any = {}): FetchArgs {
            const localVarPath = `/validators`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the vote from a voter to a delegate.
         * @summary Get the vote between a delegate and a voter
         * @param {string} delegate Delegate address
         * @param {string} voter Voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVote(delegate: string, voter: string, options: any = {}): FetchArgs {
            // verify required parameter 'delegate' is not null or undefined
            if (delegate === null || delegate === undefined) {
                throw new RequiredError('delegate','Required parameter delegate was null or undefined when calling getVote.');
            }
            // verify required parameter 'voter' is not null or undefined
            if (voter === null || voter === undefined) {
                throw new RequiredError('voter','Required parameter voter was null or undefined when calling getVote.');
            }
            const localVarPath = `/vote`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delegate !== undefined) {
                localVarQueryParameter['delegate'] = delegate;
            }

            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the votes to a delegate as a map of [voter address] => [votes]
         * @summary Get all votes of a delegate
         * @param {string} delegate Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVotes(delegate: string, options: any = {}): FetchArgs {
            // verify required parameter 'delegate' is not null or undefined
            if (delegate === null || delegate === undefined) {
                throw new RequiredError('delegate','Required parameter delegate was null or undefined when calling getVotes.');
            }
            const localVarPath = `/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delegate !== undefined) {
                localVarQueryParameter['delegate'] = delegate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DelegateApi - functional programming interface
 * @export
 */
export const DelegateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the information about delegate.
         * @summary Get delegate info
         * @param {string} address Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegate(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDelegateResponse> {
            const localVarFetchArgs = DelegateApiFetchParamCreator(configuration).getDelegate(address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of delegates.
         * @summary Get all delegates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegates(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDelegatesResponse> {
            const localVarFetchArgs = DelegateApiFetchParamCreator(configuration).getDelegates(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of validators in Semux addresses.
         * @summary Get all validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetValidatorsResponse> {
            const localVarFetchArgs = DelegateApiFetchParamCreator(configuration).getValidators(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the vote from a voter to a delegate.
         * @summary Get the vote between a delegate and a voter
         * @param {string} delegate Delegate address
         * @param {string} voter Voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVote(delegate: string, voter: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetVoteResponse> {
            const localVarFetchArgs = DelegateApiFetchParamCreator(configuration).getVote(delegate, voter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all the votes to a delegate as a map of [voter address] => [votes]
         * @summary Get all votes of a delegate
         * @param {string} delegate Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVotes(delegate: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetVotesResponse> {
            const localVarFetchArgs = DelegateApiFetchParamCreator(configuration).getVotes(delegate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DelegateApi - factory interface
 * @export
 */
export const DelegateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the information about delegate.
         * @summary Get delegate info
         * @param {string} address Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegate(address: string, options?: any) {
            return DelegateApiFp(configuration).getDelegate(address, options)(fetch, basePath);
        },
        /**
         * Returns a list of delegates.
         * @summary Get all delegates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegates(options?: any) {
            return DelegateApiFp(configuration).getDelegates(options)(fetch, basePath);
        },
        /**
         * Returns a list of validators in Semux addresses.
         * @summary Get all validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any) {
            return DelegateApiFp(configuration).getValidators(options)(fetch, basePath);
        },
        /**
         * Returns the vote from a voter to a delegate.
         * @summary Get the vote between a delegate and a voter
         * @param {string} delegate Delegate address
         * @param {string} voter Voter address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVote(delegate: string, voter: string, options?: any) {
            return DelegateApiFp(configuration).getVote(delegate, voter, options)(fetch, basePath);
        },
        /**
         * Returns all the votes to a delegate as a map of [voter address] => [votes]
         * @summary Get all votes of a delegate
         * @param {string} delegate Delegate address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVotes(delegate: string, options?: any) {
            return DelegateApiFp(configuration).getVotes(delegate, options)(fetch, basePath);
        },
    };
};

/**
 * DelegateApi - object-oriented interface
 * @export
 * @class DelegateApi
 * @extends {BaseAPI}
 */
export class DelegateApi extends BaseAPI {
    /**
     * Returns the information about delegate.
     * @summary Get delegate info
     * @param {string} address Delegate address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public getDelegate(address: string, options?: any) {
        return DelegateApiFp(this.configuration).getDelegate(address, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of delegates.
     * @summary Get all delegates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public getDelegates(options?: any) {
        return DelegateApiFp(this.configuration).getDelegates(options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of validators in Semux addresses.
     * @summary Get all validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public getValidators(options?: any) {
        return DelegateApiFp(this.configuration).getValidators(options)(this.fetch, this.basePath);
    }

    /**
     * Returns the vote from a voter to a delegate.
     * @summary Get the vote between a delegate and a voter
     * @param {string} delegate Delegate address
     * @param {string} voter Voter address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public getVote(delegate: string, voter: string, options?: any) {
        return DelegateApiFp(this.configuration).getVote(delegate, voter, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all the votes to a delegate as a map of [voter address] => [votes]
     * @summary Get all votes of a delegate
     * @param {string} delegate Delegate address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DelegateApi
     */
    public getVotes(delegate: string, options?: any) {
        return DelegateApiFp(this.configuration).getVotes(delegate, options)(this.fetch, this.basePath);
    }

}
/**
 * NodeApi - fetch parameter creator
 * @export
 */
export const NodeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a node to node manager.
         * @summary Add a node to connect
         * @param {string} node Address of the node in host:port format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNode(node: string, options: any = {}): FetchArgs {
            // verify required parameter 'node' is not null or undefined
            if (node === null || node === undefined) {
                throw new RequiredError('node','Required parameter node was null or undefined when calling addNode.');
            }
            const localVarPath = `/node`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an IP address to blacklist.
         * @summary Add an IP to blacklist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBlacklist(ip: string, options: any = {}): FetchArgs {
            // verify required parameter 'ip' is not null or undefined
            if (ip === null || ip === undefined) {
                throw new RequiredError('ip','Required parameter ip was null or undefined when calling addToBlacklist.');
            }
            const localVarPath = `/blacklist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an IP address to whitelist.
         * @summary Add an IP to whitelist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToWhitelist(ip: string, options: any = {}): FetchArgs {
            // verify required parameter 'ip' is not null or undefined
            if (ip === null || ip === undefined) {
                throw new RequiredError('ip','Required parameter ip was null or undefined when calling addToWhitelist.');
            }
            const localVarPath = `/whitelist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns kernel info.
         * @summary Get node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options: any = {}): FetchArgs {
            const localVarPath = `/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all connected peers.
         * @summary Get all peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers(options: any = {}): FetchArgs {
            const localVarPath = `/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the pending transactions.
         * @summary Get pending transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactions(options: any = {}): FetchArgs {
            const localVarPath = `/pending-transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object with data about the sync status
         * @summary Get syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncingStatus(options: any = {}): FetchArgs {
            const localVarPath = `/syncing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeApi - functional programming interface
 * @export
 */
export const NodeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a node to node manager.
         * @summary Add a node to connect
         * @param {string} node Address of the node in host:port format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNode(node: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddNodeResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).addNode(node, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds an IP address to blacklist.
         * @summary Add an IP to blacklist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBlacklist(ip: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddToBlacklistResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).addToBlacklist(ip, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds an IP address to whitelist.
         * @summary Add an IP to whitelist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToWhitelist(ip: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddToWhitelistResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).addToWhitelist(ip, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns kernel info.
         * @summary Get node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInfoResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).getInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all connected peers.
         * @summary Get all peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPeersResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).getPeers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all the pending transactions.
         * @summary Get pending transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPendingTransactionsResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).getPendingTransactions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an object with data about the sync status
         * @summary Get syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncingStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSyncingStatusResponse> {
            const localVarFetchArgs = NodeApiFetchParamCreator(configuration).getSyncingStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NodeApi - factory interface
 * @export
 */
export const NodeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a node to node manager.
         * @summary Add a node to connect
         * @param {string} node Address of the node in host:port format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNode(node: string, options?: any) {
            return NodeApiFp(configuration).addNode(node, options)(fetch, basePath);
        },
        /**
         * Adds an IP address to blacklist.
         * @summary Add an IP to blacklist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToBlacklist(ip: string, options?: any) {
            return NodeApiFp(configuration).addToBlacklist(ip, options)(fetch, basePath);
        },
        /**
         * Adds an IP address to whitelist.
         * @summary Add an IP to whitelist
         * @param {string} ip IP address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToWhitelist(ip: string, options?: any) {
            return NodeApiFp(configuration).addToWhitelist(ip, options)(fetch, basePath);
        },
        /**
         * Returns kernel info.
         * @summary Get node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any) {
            return NodeApiFp(configuration).getInfo(options)(fetch, basePath);
        },
        /**
         * Returns all connected peers.
         * @summary Get all peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers(options?: any) {
            return NodeApiFp(configuration).getPeers(options)(fetch, basePath);
        },
        /**
         * Returns all the pending transactions.
         * @summary Get pending transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTransactions(options?: any) {
            return NodeApiFp(configuration).getPendingTransactions(options)(fetch, basePath);
        },
        /**
         * Returns an object with data about the sync status
         * @summary Get syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncingStatus(options?: any) {
            return NodeApiFp(configuration).getSyncingStatus(options)(fetch, basePath);
        },
    };
};

/**
 * NodeApi - object-oriented interface
 * @export
 * @class NodeApi
 * @extends {BaseAPI}
 */
export class NodeApi extends BaseAPI {
    /**
     * Adds a node to node manager.
     * @summary Add a node to connect
     * @param {string} node Address of the node in host:port format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public addNode(node: string, options?: any) {
        return NodeApiFp(this.configuration).addNode(node, options)(this.fetch, this.basePath);
    }

    /**
     * Adds an IP address to blacklist.
     * @summary Add an IP to blacklist
     * @param {string} ip IP address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public addToBlacklist(ip: string, options?: any) {
        return NodeApiFp(this.configuration).addToBlacklist(ip, options)(this.fetch, this.basePath);
    }

    /**
     * Adds an IP address to whitelist.
     * @summary Add an IP to whitelist
     * @param {string} ip IP address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public addToWhitelist(ip: string, options?: any) {
        return NodeApiFp(this.configuration).addToWhitelist(ip, options)(this.fetch, this.basePath);
    }

    /**
     * Returns kernel info.
     * @summary Get node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getInfo(options?: any) {
        return NodeApiFp(this.configuration).getInfo(options)(this.fetch, this.basePath);
    }

    /**
     * Returns all connected peers.
     * @summary Get all peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getPeers(options?: any) {
        return NodeApiFp(this.configuration).getPeers(options)(this.fetch, this.basePath);
    }

    /**
     * Returns all the pending transactions.
     * @summary Get pending transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getPendingTransactions(options?: any) {
        return NodeApiFp(this.configuration).getPendingTransactions(options)(this.fetch, this.basePath);
    }

    /**
     * Returns an object with data about the sync status
     * @summary Get syncing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getSyncingStatus(options?: any) {
        return NodeApiFp(this.configuration).getSyncingStatus(options)(this.fetch, this.basePath);
    }

}
/**
 * ToolApi - fetch parameter creator
 * @export
 */
export const ToolApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Broadcasts a signed raw transaction to the network.
         * @summary Broadcast a raw transaction
         * @param {string} raw Raw transaction encoded in hexadecimal string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastRawTransaction(raw: string, options: any = {}): FetchArgs {
            // verify required parameter 'raw' is not null or undefined
            if (raw === null || raw === undefined) {
                throw new RequiredError('raw','Required parameter raw was null or undefined when calling broadcastRawTransaction.');
            }
            const localVarPath = `/broadcast-raw-transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compose an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be signed using /sign-raw-transaction API.
         * @summary Compose an unsigned raw transaction
         * @param {string} network Network name
         * @param {string} type Transaction type
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [timestamp] Transaction timestamp in milliseconds. Default to current time.
         * @param {string} [data] Hexadecimal encoded transaction data.
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composeRawTransaction(network: string, type: string, to: string, value: string, fee?: string, nonce?: string, timestamp?: string, data?: string, gas?: string, gasPrice?: string, options: any = {}): FetchArgs {
            // verify required parameter 'network' is not null or undefined
            if (network === null || network === undefined) {
                throw new RequiredError('network','Required parameter network was null or undefined when calling composeRawTransaction.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling composeRawTransaction.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling composeRawTransaction.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling composeRawTransaction.');
            }
            const localVarPath = `/compose-raw-transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (fee !== undefined) {
                localVarQueryParameter['fee'] = fee;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate the gas usage of a transaction.
         * @summary Estimate gas usage
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options: any = {}): FetchArgs {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling estimateGas.');
            }
            const localVarPath = `/estimate-gas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes a new message call immediately without creating a transaction on the block chain.
         * @summary Make a local call
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCall(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options: any = {}): FetchArgs {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling localCall.');
            }
            const localVarPath = `/local-call`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes a contract deployment immediately without creating a transaction on the block chain.
         * @summary Make a local create
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCreate(value?: string, data?: string, gas?: string, gasPrice?: string, options: any = {}): FetchArgs {
            const localVarPath = `/local-create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a signed message.
         * @summary Verify a message
         * @param {string} address Address of the message signer
         * @param {string} message Message in UTF-8 string
         * @param {string} signature Signature to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMessage(address: string, message: string, signature: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling verifyMessage.');
            }
            // verify required parameter 'message' is not null or undefined
            if (message === null || message === undefined) {
                throw new RequiredError('message','Required parameter message was null or undefined when calling verifyMessage.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling verifyMessage.');
            }
            const localVarPath = `/verify-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ToolApi - functional programming interface
 * @export
 */
export const ToolApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Broadcasts a signed raw transaction to the network.
         * @summary Broadcast a raw transaction
         * @param {string} raw Raw transaction encoded in hexadecimal string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastRawTransaction(raw: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).broadcastRawTransaction(raw, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compose an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be signed using /sign-raw-transaction API.
         * @summary Compose an unsigned raw transaction
         * @param {string} network Network name
         * @param {string} type Transaction type
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [timestamp] Transaction timestamp in milliseconds. Default to current time.
         * @param {string} [data] Hexadecimal encoded transaction data.
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composeRawTransaction(network: string, type: string, to: string, value: string, fee?: string, nonce?: string, timestamp?: string, data?: string, gas?: string, gasPrice?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComposeRawTransactionResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).composeRawTransaction(network, type, to, value, fee, nonce, timestamp, data, gas, gasPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate the gas usage of a transaction.
         * @summary Estimate gas usage
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstimateGasResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).estimateGas(to, value, data, gas, gasPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Executes a new message call immediately without creating a transaction on the block chain.
         * @summary Make a local call
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCall(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LocalCallResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).localCall(to, value, data, gas, gasPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Executes a contract deployment immediately without creating a transaction on the block chain.
         * @summary Make a local create
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCreate(value?: string, data?: string, gas?: string, gasPrice?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LocalCreateResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).localCreate(value, data, gas, gasPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Verify a signed message.
         * @summary Verify a message
         * @param {string} address Address of the message signer
         * @param {string} message Message in UTF-8 string
         * @param {string} signature Signature to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMessage(address: string, message: string, signature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyMessageResponse> {
            const localVarFetchArgs = ToolApiFetchParamCreator(configuration).verifyMessage(address, message, signature, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ToolApi - factory interface
 * @export
 */
export const ToolApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Broadcasts a signed raw transaction to the network.
         * @summary Broadcast a raw transaction
         * @param {string} raw Raw transaction encoded in hexadecimal string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastRawTransaction(raw: string, options?: any) {
            return ToolApiFp(configuration).broadcastRawTransaction(raw, options)(fetch, basePath);
        },
        /**
         * Compose an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be signed using /sign-raw-transaction API.
         * @summary Compose an unsigned raw transaction
         * @param {string} network Network name
         * @param {string} type Transaction type
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [timestamp] Transaction timestamp in milliseconds. Default to current time.
         * @param {string} [data] Hexadecimal encoded transaction data.
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composeRawTransaction(network: string, type: string, to: string, value: string, fee?: string, nonce?: string, timestamp?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
            return ToolApiFp(configuration).composeRawTransaction(network, type, to, value, fee, nonce, timestamp, data, gas, gasPrice, options)(fetch, basePath);
        },
        /**
         * Estimate the gas usage of a transaction.
         * @summary Estimate gas usage
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
            return ToolApiFp(configuration).estimateGas(to, value, data, gas, gasPrice, options)(fetch, basePath);
        },
        /**
         * Executes a new message call immediately without creating a transaction on the block chain.
         * @summary Make a local call
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCall(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
            return ToolApiFp(configuration).localCall(to, value, data, gas, gasPrice, options)(fetch, basePath);
        },
        /**
         * Executes a contract deployment immediately without creating a transaction on the block chain.
         * @summary Make a local create
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {string} [gas] The gas limit for the call
         * @param {string} [gasPrice] The gas price in nano SEM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localCreate(value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
            return ToolApiFp(configuration).localCreate(value, data, gas, gasPrice, options)(fetch, basePath);
        },
        /**
         * Verify a signed message.
         * @summary Verify a message
         * @param {string} address Address of the message signer
         * @param {string} message Message in UTF-8 string
         * @param {string} signature Signature to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMessage(address: string, message: string, signature: string, options?: any) {
            return ToolApiFp(configuration).verifyMessage(address, message, signature, options)(fetch, basePath);
        },
    };
};

/**
 * ToolApi - object-oriented interface
 * @export
 * @class ToolApi
 * @extends {BaseAPI}
 */
export class ToolApi extends BaseAPI {
    /**
     * Broadcasts a signed raw transaction to the network.
     * @summary Broadcast a raw transaction
     * @param {string} raw Raw transaction encoded in hexadecimal string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public broadcastRawTransaction(raw: string, options?: any) {
        return ToolApiFp(this.configuration).broadcastRawTransaction(raw, options)(this.fetch, this.basePath);
    }

    /**
     * Compose an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be signed using /sign-raw-transaction API.
     * @summary Compose an unsigned raw transaction
     * @param {string} network Network name
     * @param {string} type Transaction type
     * @param {string} to Recipient&#x27;s address
     * @param {string} value Amount of value to transfer in nano SEM
     * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {string} [timestamp] Transaction timestamp in milliseconds. Default to current time.
     * @param {string} [data] Hexadecimal encoded transaction data.
     * @param {string} [gas] The gas limit for the call
     * @param {string} [gasPrice] The gas price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public composeRawTransaction(network: string, type: string, to: string, value: string, fee?: string, nonce?: string, timestamp?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
        return ToolApiFp(this.configuration).composeRawTransaction(network, type, to, value, fee, nonce, timestamp, data, gas, gasPrice, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate the gas usage of a transaction.
     * @summary Estimate gas usage
     * @param {string} to Recipient&#x27;s address (the contract address)
     * @param {string} [value] Amount of value to transfer in nano SEM
     * @param {string} [data] Transaction data encoded in hexadecimal string
     * @param {string} [gas] The gas limit for the call
     * @param {string} [gasPrice] The gas price in nano SEM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public estimateGas(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
        return ToolApiFp(this.configuration).estimateGas(to, value, data, gas, gasPrice, options)(this.fetch, this.basePath);
    }

    /**
     * Executes a new message call immediately without creating a transaction on the block chain.
     * @summary Make a local call
     * @param {string} to Recipient&#x27;s address (the contract address)
     * @param {string} [value] Amount of value to transfer in nano SEM
     * @param {string} [data] Transaction data encoded in hexadecimal string
     * @param {string} [gas] The gas limit for the call
     * @param {string} [gasPrice] The gas price in nano SEM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public localCall(to: string, value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
        return ToolApiFp(this.configuration).localCall(to, value, data, gas, gasPrice, options)(this.fetch, this.basePath);
    }

    /**
     * Executes a contract deployment immediately without creating a transaction on the block chain.
     * @summary Make a local create
     * @param {string} [value] Amount of value to transfer in nano SEM
     * @param {string} [data] Transaction data encoded in hexadecimal string
     * @param {string} [gas] The gas limit for the call
     * @param {string} [gasPrice] The gas price in nano SEM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public localCreate(value?: string, data?: string, gas?: string, gasPrice?: string, options?: any) {
        return ToolApiFp(this.configuration).localCreate(value, data, gas, gasPrice, options)(this.fetch, this.basePath);
    }

    /**
     * Verify a signed message.
     * @summary Verify a message
     * @param {string} address Address of the message signer
     * @param {string} message Message in UTF-8 string
     * @param {string} signature Signature to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public verifyMessage(address: string, message: string, signature: string, options?: any) {
        return ToolApiFp(this.configuration).verifyMessage(address, message, signature, options)(this.fetch, this.basePath);
    }

}
/**
 * WalletApi - fetch parameter creator
 * @export
 */
export const WalletApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call a VM contract.
         * @summary Call a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price in nano SEM
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        call(from: string, to: string, gas: string, gasPrice: string, value?: string, nonce?: string, data?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling call.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling call.');
            }
            // verify required parameter 'gas' is not null or undefined
            if (gas === null || gas === undefined) {
                throw new RequiredError('gas','Required parameter gas was null or undefined when calling call.');
            }
            // verify required parameter 'gasPrice' is not null or undefined
            if (gasPrice === null || gasPrice === undefined) {
                throw new RequiredError('gasPrice','Required parameter gasPrice was null or undefined when calling call.');
            }
            const localVarPath = `/transaction/call`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a VM contract.
         * @summary Deploy a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} data The contract data encoded in hexadecimal string
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price
         * @param {string} [value] Amount of SEM to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(from: string, data: string, gas: string, gasPrice: string, value?: string, nonce?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling create.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling create.');
            }
            // verify required parameter 'gas' is not null or undefined
            if (gas === null || gas === undefined) {
                throw new RequiredError('gas','Required parameter gas was null or undefined when calling create.');
            }
            // verify required parameter 'gasPrice' is not null or undefined
            if (gasPrice === null || gasPrice === undefined) {
                throw new RequiredError('gasPrice','Required parameter gasPrice was null or undefined when calling create.');
            }
            const localVarPath = `/transaction/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (gas !== undefined) {
                localVarQueryParameter['gas'] = gas;
            }

            if (gasPrice !== undefined) {
                localVarQueryParameter['gasPrice'] = gasPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account by generating a new private key or importing an existing private key when parameter 'privateKey' is provided.
         * @summary Create or import an account to wallet
         * @param {string} [name] Assigned alias to the created account.
         * @param {string} [privateKey] The private key to be imported, create a new key if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(name?: string, privateKey?: string, options: any = {}): FetchArgs {
            const localVarPath = `/create-account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (privateKey !== undefined) {
                localVarQueryParameter['privateKey'] = privateKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers as a delegate
         * @summary Register as delegate
         * @param {string} from Registering address
         * @param {string} data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegate(from: string, data: string, fee?: string, nonce?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling delegate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling delegate.');
            }
            const localVarPath = `/transaction/delegate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (fee !== undefined) {
                localVarQueryParameter['fee'] = fee;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an account from this wallet.
         * @summary Delete an account from wallet
         * @param {string} address Address of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/delete-account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns accounts in the wallet.
         * @summary List all accounts in wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a message.
         * @summary Sign a message
         * @param {string} address Signing address. The address must exist in the wallet.data of this Semux node.
         * @param {string} message Message to sign in UTF-8 string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signMessage(address: string, message: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling signMessage.');
            }
            // verify required parameter 'message' is not null or undefined
            if (message === null || message === undefined) {
                throw new RequiredError('message','Required parameter message was null or undefined when calling signMessage.');
            }
            const localVarPath = `/sign-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be created using /compose-raw-transaction API.
         * @summary Sign an unsigned raw transaction
         * @param {string} raw Unsigned raw transaction encoded in hexadecimal string.
         * @param {string} address Signer&#x27;s address. This address must exist in the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signRawTransaction(raw: string, address: string, options: any = {}): FetchArgs {
            // verify required parameter 'raw' is not null or undefined
            if (raw === null || raw === undefined) {
                throw new RequiredError('raw','Required parameter raw was null or undefined when calling signRawTransaction.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling signRawTransaction.');
            }
            const localVarPath = `/sign-raw-transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfers coins to another address.
         * @summary Transfer coins
         * @param {string} from Sender&#x27;s address. The account must exist in the wallet of this node.
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transfer(from: string, to: string, value: string, fee?: string, nonce?: string, data?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling transfer.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling transfer.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling transfer.');
            }
            const localVarPath = `/transaction/transfer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (fee !== undefined) {
                localVarQueryParameter['fee'] = fee;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unvotes for a delegate.
         * @summary Unvote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unvote(from: string, to: string, value: string, fee?: string, nonce?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling unvote.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling unvote.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling unvote.');
            }
            const localVarPath = `/transaction/unvote`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (fee !== undefined) {
                localVarQueryParameter['fee'] = fee;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Votes for a delegate.
         * @summary Vote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(from: string, to: string, value: string, fee?: string, nonce?: string, options: any = {}): FetchArgs {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling vote.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling vote.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling vote.');
            }
            const localVarPath = `/transaction/vote`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (fee !== undefined) {
                localVarQueryParameter['fee'] = fee;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Call a VM contract.
         * @summary Call a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price in nano SEM
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        call(from: string, to: string, gas: string, gasPrice: string, value?: string, nonce?: string, data?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).call(from, to, gas, gasPrice, value, nonce, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a VM contract.
         * @summary Deploy a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} data The contract data encoded in hexadecimal string
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price
         * @param {string} [value] Amount of SEM to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(from: string, data: string, gas: string, gasPrice: string, value?: string, nonce?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).create(from, data, gas, gasPrice, value, nonce, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new account by generating a new private key or importing an existing private key when parameter 'privateKey' is provided.
         * @summary Create or import an account to wallet
         * @param {string} [name] Assigned alias to the created account.
         * @param {string} [privateKey] The private key to be imported, create a new key if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(name?: string, privateKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAccountResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).createAccount(name, privateKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers as a delegate
         * @summary Register as delegate
         * @param {string} from Registering address
         * @param {string} data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegate(from: string, data: string, fee?: string, nonce?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).delegate(from, data, fee, nonce, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an account from this wallet.
         * @summary Delete an account from wallet
         * @param {string} address Address of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAccountResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).deleteAccount(address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns accounts in the wallet.
         * @summary List all accounts in wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAccountsResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getAccounts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sign a message.
         * @summary Sign a message
         * @param {string} address Signing address. The address must exist in the wallet.data of this Semux node.
         * @param {string} message Message to sign in UTF-8 string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signMessage(address: string, message: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignMessageResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).signMessage(address, message, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sign an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be created using /compose-raw-transaction API.
         * @summary Sign an unsigned raw transaction
         * @param {string} raw Unsigned raw transaction encoded in hexadecimal string.
         * @param {string} address Signer&#x27;s address. This address must exist in the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signRawTransaction(raw: string, address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignRawTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).signRawTransaction(raw, address, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfers coins to another address.
         * @summary Transfer coins
         * @param {string} from Sender&#x27;s address. The account must exist in the wallet of this node.
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transfer(from: string, to: string, value: string, fee?: string, nonce?: string, data?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).transfer(from, to, value, fee, nonce, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unvotes for a delegate.
         * @summary Unvote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unvote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).unvote(from, to, value, fee, nonce, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Votes for a delegate.
         * @summary Vote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DoTransactionResponse> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).vote(from, to, value, fee, nonce, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Call a VM contract.
         * @summary Call a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Recipient&#x27;s address (the contract address)
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price in nano SEM
         * @param {string} [value] Amount of value to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        call(from: string, to: string, gas: string, gasPrice: string, value?: string, nonce?: string, data?: string, options?: any) {
            return WalletApiFp(configuration).call(from, to, gas, gasPrice, value, nonce, data, options)(fetch, basePath);
        },
        /**
         * Create a VM contract.
         * @summary Deploy a contract
         * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} data The contract data encoded in hexadecimal string
         * @param {string} gas The gas limit for the call
         * @param {string} gasPrice The gas price
         * @param {string} [value] Amount of SEM to transfer in nano SEM
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(from: string, data: string, gas: string, gasPrice: string, value?: string, nonce?: string, options?: any) {
            return WalletApiFp(configuration).create(from, data, gas, gasPrice, value, nonce, options)(fetch, basePath);
        },
        /**
         * Creates a new account by generating a new private key or importing an existing private key when parameter 'privateKey' is provided.
         * @summary Create or import an account to wallet
         * @param {string} [name] Assigned alias to the created account.
         * @param {string} [privateKey] The private key to be imported, create a new key if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(name?: string, privateKey?: string, options?: any) {
            return WalletApiFp(configuration).createAccount(name, privateKey, options)(fetch, basePath);
        },
        /**
         * Registers as a delegate
         * @summary Register as delegate
         * @param {string} from Registering address
         * @param {string} data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegate(from: string, data: string, fee?: string, nonce?: string, options?: any) {
            return WalletApiFp(configuration).delegate(from, data, fee, nonce, options)(fetch, basePath);
        },
        /**
         * Deletes an account from this wallet.
         * @summary Delete an account from wallet
         * @param {string} address Address of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(address: string, options?: any) {
            return WalletApiFp(configuration).deleteAccount(address, options)(fetch, basePath);
        },
        /**
         * Returns accounts in the wallet.
         * @summary List all accounts in wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(options?: any) {
            return WalletApiFp(configuration).getAccounts(options)(fetch, basePath);
        },
        /**
         * Sign a message.
         * @summary Sign a message
         * @param {string} address Signing address. The address must exist in the wallet.data of this Semux node.
         * @param {string} message Message to sign in UTF-8 string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signMessage(address: string, message: string, options?: any) {
            return WalletApiFp(configuration).signMessage(address, message, options)(fetch, basePath);
        },
        /**
         * Sign an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be created using /compose-raw-transaction API.
         * @summary Sign an unsigned raw transaction
         * @param {string} raw Unsigned raw transaction encoded in hexadecimal string.
         * @param {string} address Signer&#x27;s address. This address must exist in the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signRawTransaction(raw: string, address: string, options?: any) {
            return WalletApiFp(configuration).signRawTransaction(raw, address, options)(fetch, basePath);
        },
        /**
         * Transfers coins to another address.
         * @summary Transfer coins
         * @param {string} from Sender&#x27;s address. The account must exist in the wallet of this node.
         * @param {string} to Recipient&#x27;s address
         * @param {string} value Amount of value to transfer in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {string} [data] Transaction data encoded in hexadecimal string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transfer(from: string, to: string, value: string, fee?: string, nonce?: string, data?: string, options?: any) {
            return WalletApiFp(configuration).transfer(from, to, value, fee, nonce, data, options)(fetch, basePath);
        },
        /**
         * Unvotes for a delegate.
         * @summary Unvote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unvote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any) {
            return WalletApiFp(configuration).unvote(from, to, value, fee, nonce, options)(fetch, basePath);
        },
        /**
         * Votes for a delegate.
         * @summary Vote for a delegate
         * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
         * @param {string} to Delegate address
         * @param {string} value Number of votes in nano SEM
         * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
         * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any) {
            return WalletApiFp(configuration).vote(from, to, value, fee, nonce, options)(fetch, basePath);
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * Call a VM contract.
     * @summary Call a contract
     * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
     * @param {string} to Recipient&#x27;s address (the contract address)
     * @param {string} gas The gas limit for the call
     * @param {string} gasPrice The gas price in nano SEM
     * @param {string} [value] Amount of value to transfer in nano SEM
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {string} [data] Transaction data encoded in hexadecimal string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public call(from: string, to: string, gas: string, gasPrice: string, value?: string, nonce?: string, data?: string, options?: any) {
        return WalletApiFp(this.configuration).call(from, to, gas, gasPrice, value, nonce, data, options)(this.fetch, this.basePath);
    }

    /**
     * Create a VM contract.
     * @summary Deploy a contract
     * @param {string} from Sender&#x27;s address. The address must exist in the wallet.data of this Semux node.
     * @param {string} data The contract data encoded in hexadecimal string
     * @param {string} gas The gas limit for the call
     * @param {string} gasPrice The gas price
     * @param {string} [value] Amount of SEM to transfer in nano SEM
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public create(from: string, data: string, gas: string, gasPrice: string, value?: string, nonce?: string, options?: any) {
        return WalletApiFp(this.configuration).create(from, data, gas, gasPrice, value, nonce, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new account by generating a new private key or importing an existing private key when parameter 'privateKey' is provided.
     * @summary Create or import an account to wallet
     * @param {string} [name] Assigned alias to the created account.
     * @param {string} [privateKey] The private key to be imported, create a new key if omitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public createAccount(name?: string, privateKey?: string, options?: any) {
        return WalletApiFp(this.configuration).createAccount(name, privateKey, options)(this.fetch, this.basePath);
    }

    /**
     * Registers as a delegate
     * @summary Register as delegate
     * @param {string} from Registering address
     * @param {string} data Delegate name in hexadecimal encoded UTF-8 string, 16 bytes of data at maximum
     * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public delegate(from: string, data: string, fee?: string, nonce?: string, options?: any) {
        return WalletApiFp(this.configuration).delegate(from, data, fee, nonce, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an account from this wallet.
     * @summary Delete an account from wallet
     * @param {string} address Address of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public deleteAccount(address: string, options?: any) {
        return WalletApiFp(this.configuration).deleteAccount(address, options)(this.fetch, this.basePath);
    }

    /**
     * Returns accounts in the wallet.
     * @summary List all accounts in wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getAccounts(options?: any) {
        return WalletApiFp(this.configuration).getAccounts(options)(this.fetch, this.basePath);
    }

    /**
     * Sign a message.
     * @summary Sign a message
     * @param {string} address Signing address. The address must exist in the wallet.data of this Semux node.
     * @param {string} message Message to sign in UTF-8 string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public signMessage(address: string, message: string, options?: any) {
        return WalletApiFp(this.configuration).signMessage(address, message, options)(this.fetch, this.basePath);
    }

    /**
     * Sign an unsigned raw transaction then return its hexadecimal encoded string. An unsigned raw transaction can be created using /compose-raw-transaction API.
     * @summary Sign an unsigned raw transaction
     * @param {string} raw Unsigned raw transaction encoded in hexadecimal string.
     * @param {string} address Signer&#x27;s address. This address must exist in the wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public signRawTransaction(raw: string, address: string, options?: any) {
        return WalletApiFp(this.configuration).signRawTransaction(raw, address, options)(this.fetch, this.basePath);
    }

    /**
     * Transfers coins to another address.
     * @summary Transfer coins
     * @param {string} from Sender&#x27;s address. The account must exist in the wallet of this node.
     * @param {string} to Recipient&#x27;s address
     * @param {string} value Amount of value to transfer in nano SEM
     * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {string} [data] Transaction data encoded in hexadecimal string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public transfer(from: string, to: string, value: string, fee?: string, nonce?: string, data?: string, options?: any) {
        return WalletApiFp(this.configuration).transfer(from, to, value, fee, nonce, data, options)(this.fetch, this.basePath);
    }

    /**
     * Unvotes for a delegate.
     * @summary Unvote for a delegate
     * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
     * @param {string} to Delegate address
     * @param {string} value Number of votes in nano SEM
     * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public unvote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any) {
        return WalletApiFp(this.configuration).unvote(from, to, value, fee, nonce, options)(this.fetch, this.basePath);
    }

    /**
     * Votes for a delegate.
     * @summary Vote for a delegate
     * @param {string} from Voter&#x27;s address. The address must exist in the wallet.data of this Semux node.
     * @param {string} to Delegate address
     * @param {string} value Number of votes in nano SEM
     * @param {string} [fee] Transaction fee in nano SEM, default to minimum fee if omitted
     * @param {string} [nonce] Transaction nonce, default to sender&#x27;s nonce if omitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public vote(from: string, to: string, value: string, fee?: string, nonce?: string, options?: any) {
        return WalletApiFp(this.configuration).vote(from, to, value, fee, nonce, options)(this.fetch, this.basePath);
    }

}
